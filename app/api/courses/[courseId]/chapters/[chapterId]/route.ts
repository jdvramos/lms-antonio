import { db } from "@/lib/db";
import { auth } from "@clerk/nextjs";
import { NextResponse } from "next/server";

import Mux from "@mux/mux-node";

const { Video } = new Mux(
    process.env.MUX_TOKEN_ID!,
    process.env.MUX_TOKEN_SECRET!
);

export async function PATCH(
    req: Request,
    { params }: { params: { courseId: string; chapterId: string } }
) {
    try {
        const { userId } = auth();

        /* 
            This req body will came from a patch req from different components 
            under /teacher/courses/[courseId]/chapters/[chapterId]/_components
              - chapter-title-form.tsx
              - chapter-description-form.tsx
              - chapter-access-form.tsx
              - chapter-video-form.tsx
			
			Here we used destructuring to extract isPublished out of the rest
			(values). The reason behind this that users cannot accidentally set
			isPublished to true, immediately passed that into values in our update 
			below and the chapter is published. The mechanism of chapter publishing
			will be controlled by a separate API route which is going to check
			whether we have all the required fields to publish a chapter
        */
        const { isPublished, ...values } = await req.json();

        /* 
			Check if there's a logged in user (authentication)
		*/
        if (!userId) {
            return new NextResponse("Unauthorized", { status: 401 });
        }

        /* 
			Check if the user updating the course (specifically chapters) 
            is the owner of the course (authorization)
		*/
        const courseOwner = await db.course.findUnique({
            where: {
                id: params.courseId,
                userId,
            },
        });

        if (!courseOwner) {
            return new NextResponse("Unauthorized", { status: 401 });
        }

        const chapter = await db.chapter.update({
            where: {
                id: params.chapterId,
                courseId: params.courseId,
            },
            data: {
                ...values,
            },
        });

        /*  
            If the values contain videoUrl (a patch req came from chapter-video-form.tsx)
            then proceed to process the video in the database and in the MUX
        */
        if (values.videoUrl) {
            /*  
                Find if the chapter already have an uploaded video in the database
                by checking if the id of the chapter (chapterId) matched a certain
                muxData in the database. If so, delete the existingMuxData on MUX 
                and in the database
            */
            const existingMuxData = await db.muxData.findFirst({
                where: {
                    chapterId: params.chapterId,
                },
            });

            if (existingMuxData) {
                await Video.Assets.del(existingMuxData.assetId);
                await db.muxData.delete({
                    where: {
                        id: existingMuxData.id,
                    },
                });
            }

            /*  
                Start to upload the videoUrl of the chapter (generated by the UploadThing)
                into MUX
            */
            const asset = await Video.Assets.create({
                input: values.videoUrl,
                playback_policy: "public",
                test: false,
            });

            /*  
                Once the upload of videoUrl of the chapter into MUX has finished proceed
                in storing the muxData into the database
            */
            await db.muxData.create({
                data: {
                    chapterId: params.chapterId,
                    assetId: asset.id,
                    playbackId: asset.playback_ids?.[0]?.id,
                },
            });
        }

        return NextResponse.json(chapter);
    } catch (error) {
        console.log("[COURSES_CHAPTER_ID]", error);
        return new NextResponse("Internal Error", { status: 500 });
    }
}

export async function DELETE(
    req: Request,
    { params }: { params: { courseId: string; chapterId: string } }
) {
    try {
        const { userId } = auth();

        /* 
			Check if there's a logged in user (authentication)
		*/
        if (!userId) {
            return new NextResponse("Unauthorized", { status: 401 });
        }

        /* 
			Check if the user deleting a chapter of a course
            is the owner of the course (authorization)
		*/
        const courseOwner = await db.course.findUnique({
            where: {
                id: params.courseId,
                userId,
            },
        });

        if (!courseOwner) {
            return new NextResponse("Unauthorized", { status: 401 });
        }

        /* 
			Check if the chapter the user is attempting to delete
            exist in the database, if not return 404 not found
		*/
        const chapter = await db.chapter.findUnique({
            where: {
                id: params.chapterId,
                courseId: params.courseId,
            },
        });

        if (!chapter) {
            return new NextResponse("Not Found", { status: 404 });
        }

        /* 
			At this point the user is authenticated, authorized and the chapter
            that is going to be deleted really exist. Next, is to find out if the
            chapter has a videoUrl data. If so, delete the video on MUX and into
            the MuxData table
		*/
        if (chapter.videoUrl) {
            /* 
                First, find if such chapter exist in the MuxData table
		    */
            const existingMuxData = await db.muxData.findFirst({
                where: {
                    chapterId: params.chapterId,
                },
            });

            /* 
                If so delete the video in MUX and the MuxData table
		    */
            if (existingMuxData) {
                await Video.Assets.del(existingMuxData.assetId);
                await db.muxData.delete({
                    where: {
                        id: existingMuxData.id,
                    },
                });
            }
        }

        /* 
			Next, delete the chapter in the Chapter table
		*/
        const deletedChapter = await db.chapter.delete({
            where: {
                id: params.chapterId,
            },
        });

        /* 
			Since we only allow a course to be publishable if at least one
            of its chapters was published. We need to perform a check.  
            By deleting a chapter, it's possible that a course will no  
            longer have at least one chapter where isPublished set to true. 
            In this case we want to make the course's isPublished set 
            back to false. Here, we are checking how many chapters are in a
            certain course where isPublished is true. If `publishedChaptersInCourse`
            length value is 0 we are going to update the course's isPublished
            value to false
		*/
        const publishedChaptersInCourse = await db.chapter.findMany({
            where: {
                courseId: params.courseId,
                isPublished: true,
            },
        });

        if (!publishedChaptersInCourse.length) {
            await db.course.update({
                where: {
                    id: params.courseId,
                },
                data: {
                    isPublished: false,
                },
            });
        }

        return NextResponse.json(deletedChapter);
    } catch (error) {
        console.log("[CHAPTER_ID_DELETE]", error);
        return new NextResponse("Internal Error", { status: 500 });
    }
}
